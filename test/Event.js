// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var Event, callBackA, channelA, contextA, idA, nameA, nameB;

  Event = require('../src/Event.js');

  idA = 1;

  channelA = 'channelA';

  nameA = 'nameA';

  nameB = 'nameB';

  callBackA = void 0;

  contextA = {
    dummy: 'context'
  };

  describe('Event', function() {
    describe('Class definition', function() {
      return it('Event API should be defined', function() {
        expect(Event).not.to.be.undefined;
        expect(Event.prototype.init).not.to.be.undefined;
        expect(Event.prototype.getId).not.to.be.undefined;
        expect(Event.prototype.getChannel).not.to.be.undefined;
        expect(Event.prototype.getCallback).not.to.be.undefined;
        expect(Event.prototype.getContext).not.to.be.undefined;
        expect(Event.prototype.getName).not.to.be.undefined;
        expect(Event.prototype.getPriority).not.to.be.undefined;
        expect(Event.prototype.incrementPriority).not.to.be.undefined;
        expect(Event.prototype.decrementPriority).not.to.be.undefined;
        expect(Event.prototype.trigger).not.to.be.undefined;
        expect(Event.prototype.isPaused).not.to.be.undefined;
        expect(Event.prototype.pause).not.to.be.undefined;
        expect(Event.prototype.resume).not.to.be.undefined;
        expect(Event.prototype.stop).not.to.be.undefined;
        return expect(Event.prototype.isStopped).not.to.be.undefined;
      });
    });
    return describe('API', function() {
      var evt;
      evt = void 0;
      beforeEach(function() {
        callBackA = sinon.spy();
        return evt = new Event({
          id: idA,
          name: nameA,
          channel: channelA,
          callBack: callBackA,
          context: contextA,
          priority: 2
        });
      });
      describe('Event -> init()', function() {
        it('should accept id, name, callBack [,channel, priority, context]', function() {
          evt = new Event({
            id: idA,
            name: nameA,
            callBack: callBackA
          });
          expect(evt.id).to.equal(idA);
          expect(evt.name).to.equal(nameA);
          expect(evt.callBack).to.equal(callBackA);
          expect(evt.callBack.callCount).to.equal(0);
          expect(evt.channel).to.equal(void 0);
          expect(evt.context).to.equal(void 0);
          return expect(evt.priority).to.equal(1);
        });
        it('should set id, name, callBack, channel, context as READ ONLY', function() {
          var editCallBackFunc, editChannelFunc, editContextFunc, editIdFunc, editNameFunc;
          editIdFunc = function() {
            return evt.id = -1;
          };
          editNameFunc = function() {
            return evt.name = '';
          };
          editChannelFunc = function() {
            return evt.channel = '';
          };
          editCallBackFunc = function() {
            return evt.callBack = function() {};
          };
          editContextFunc = function() {
            return evt.context = {};
          };
          expect(editIdFunc).to["throw"];
          expect(editNameFunc).to["throw"];
          expect(editChannelFunc).to["throw"];
          expect(editCallBackFunc).to["throw"];
          expect(editContextFunc).to["throw"];
          expect(evt.id).to.equal(idA);
          expect(evt.name).to.equal(nameA);
          expect(evt.channel).to.equal(channelA);
          expect(evt.callBack).to.equal(callBackA);
          return expect(evt.context).to.equal(contextA);
        });
        return it('should THROW TypeError on missing id, name, callBack', function() {
          var emptyCallFunc, missingCallBackFunc, missingIdFunc, missingNameFunc;
          emptyCallFunc = function() {
            return new Event;
          };
          missingIdFunc = function() {
            return new Event({
              name: nameA,
              callBack: callBackA
            });
          };
          missingNameFunc = function() {
            return new Event({
              id: idA,
              callBack: callBackA
            });
          };
          missingCallBackFunc = function() {
            return new Event({
              id: idA,
              name: nameA
            });
          };
          expect(emptyCallFunc).to["throw"];
          expect(missingIdFunc).to["throw"];
          expect(missingNameFunc).to["throw"];
          return expect(missingCallBackFunc).to["throw"];
        });
      });
      describe('Event -> trigger()', function() {
        it('should execute callBack', function() {
          expect(evt.callBack.callCount).to.equal(0);
          evt.trigger();
          return expect(evt.callBack.callCount).to.equal(1);
        });
        it('should execute callBack providing context', function() {
          var callBackB, contextB, evtB;
          contextB = {};
          callBackB = sinon.spy();
          evtB = new Event({
            id: idA,
            name: nameA,
            callBack: callBackB,
            context: contextB
          });
          expect(evt.callBack.callCount).to.equal(0);
          expect(evtB.callBack.callCount).to.equal(0);
          evt.trigger();
          evtB.trigger();
          expect(evt.callBack.callCount).to.equal(1);
          expect(evt.callBack.calledOn(contextA)).to.be["true"];
          expect(evtB.callBack.callCount).to.equal(1);
          return expect(evtB.callBack.calledOn(contextB)).to.be["true"];
        });
        return it('should execute callBack providing arguments', function() {
          var arg0, arg1, arg2, arg3;
          arg0 = 123;
          arg1 = 'abc';
          arg2 = [4, 5, 6];
          arg3 = {};
          expect(evt.callBack.callCount).to.equal(0);
          evt.trigger(arg0, arg1, arg2, arg3);
          expect(evt.callBack.callCount).to.equal(1);
          return expect(evt.callBack.firstCall.calledWith(arg0, arg1, arg2, arg3)).to.be["true"];
        });
      });
      describe('Event - Getters', function() {
        it('Event -> getId() should return id value', function() {
          return expect(evt.getId()).to.equal(idA);
        });
        it('Event -> getChannel() should return channel value', function() {
          return expect(evt.getChannel()).to.equal(channelA);
        });
        it('Event -> getCallback() should return callBack value', function() {
          return expect(evt.getCallback()).to.equal(callBackA);
        });
        it('Event -> getContext() should return context value', function() {
          return expect(evt.getContext()).to.equal(contextA);
        });
        it('Event -> getName() should return name value', function() {
          return expect(evt.getName()).to.equal(nameA);
        });
        it('Event -> getPriority() should return priority value', function() {
          return expect(evt.getPriority()).to.equal(2);
        });
        return describe('Event -> isPaused()', function() {
          it('should return false by default', function() {
            return expect(evt.isPaused()).to.be["false"];
          });
          return it('should return true after a call to pause()', function() {
            evt.pause();
            return expect(evt.isPaused()).to.be["true"];
          });
        });
      });
      return describe('Event - Setters', function() {
        describe('Event -> incrementPriority()', function() {
          it('should increment priority value by 1 when step is undefined', function() {
            var _p;
            _p = evt.getPriority();
            expect(_p).to.equal(2);
            evt.incrementPriority();
            return expect(evt.getPriority()).to.equal(_p + 1);
          });
          return it('should increment priority value by step', function() {
            var step, _p;
            _p = evt.getPriority();
            step = 2;
            expect(_p).to.equal(2);
            evt.incrementPriority(step);
            return expect(evt.getPriority()).to.equal(_p + step);
          });
        });
        describe('Event -> decrementPriority()', function() {
          it('should decrement priority value by 1 when step is undefined', function() {
            var _p;
            _p = evt.getPriority();
            expect(_p).to.equal(2);
            evt.decrementPriority();
            return expect(evt.getPriority()).to.equal(_p - 1);
          });
          return it('should decrement priority value by step', function() {
            var step, _p;
            _p = evt.getPriority();
            step = 2;
            expect(_p).to.equal(2);
            evt.decrementPriority(step);
            return expect(evt.getPriority()).to.equal(_p - step);
          });
        });
        describe('Event -> pause()', function() {
          it('should set the property paused to true', function() {
            expect(evt.paused).to.be["false"];
            evt.pause();
            return expect(evt.paused).to.be["true"];
          });
          it('should prevent trigger from executing the callBack', function() {
            expect(evt.callBack.callCount).to.equal(0);
            evt.pause();
            evt.trigger();
            return expect(evt.callBack.callCount).to.equal(0);
          });
          return it('should THROW if the event is stopped', function() {
            var pauseOnStoppedFunc;
            pauseOnStoppedFunc = function() {
              return evt.pause();
            };
            evt.stop();
            return expect(pauseOnStoppedFunc).to["throw"];
          });
        });
        describe('Event -> resume()', function() {
          it('should set the property paused to false', function() {
            evt.pause();
            expect(evt.paused).to.be["true"];
            evt.resume();
            return expect(evt.paused).to.be["false"];
          });
          it('should allow trigger executing the callBack after the event has been paused', function() {
            evt.pause();
            evt.trigger();
            expect(evt.callBack.callCount).to.equal(0);
            evt.resume();
            evt.trigger();
            return expect(evt.callBack.callCount).to.equal(1);
          });
          return it('should THROW if the event is stopped', function() {
            var resumeOnStoppedFunc;
            resumeOnStoppedFunc = function() {
              return evt.resume();
            };
            evt.stop();
            return expect(resumeOnStoppedFunc).to["throw"];
          });
        });
        return describe('Event -> stop()', function() {
          it('should set the property stopped to true', function() {
            expect(evt.stopped).to.be.undefined;
            evt.stop();
            return expect(evt.stopped).to.be["true"];
          });
          return it('should THROW on altering / triggering stopped event', function() {
            var decPriorityOnStoppedFunc, incPriorityOnStoppedFunc, pauseOnStoppedFunc, resumeOnStoppedFunc, triggerOnStoppedFunc;
            pauseOnStoppedFunc = function() {
              return evt.pause();
            };
            resumeOnStoppedFunc = function() {
              return evt.resume();
            };
            triggerOnStoppedFunc = function() {
              return evt.trigger();
            };
            incPriorityOnStoppedFunc = function() {
              return evt.incrementPriority();
            };
            decPriorityOnStoppedFunc = function() {
              return evt.decrementPriority();
            };
            evt.stop();
            expect(pauseOnStoppedFunc).to["throw"];
            expect(resumeOnStoppedFunc).to["throw"];
            expect(triggerOnStoppedFunc).to["throw"];
            expect(incPriorityOnStoppedFunc).to["throw"];
            return expect(decPriorityOnStoppedFunc).to["throw"];
          });
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=Event.js.map
